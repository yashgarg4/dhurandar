<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Dhurandar</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
    />
    <meta name="generator" content="Scirra Construct" />
    <meta name="author" content="JioGames" />
    <link rel="manifest" href="appmanifest.json" />
    <link rel="apple-touch-icon" sizes="128x128" href="icons/icon-128.png" />
    <link rel="apple-touch-icon" sizes="256x256" href="icons/icon-256.png" />
    <link rel="apple-touch-icon" sizes="512x512" href="icons/icon-512.png" />
    <link rel="icon" type="image/png" href="icons/icon-512.png" />
    <link rel="stylesheet" href="style.css" />
    <style>
      /* safety defaults */
      html,
      body {
        -webkit-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }

      /* iframe overlay */
      #pipepuzzle_iframe_wrap {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 99999;
        pointer-events: none;
        -webkit-tap-highlight-color: transparent;
      }
      .pipepuzzle_iframe {
        width: 960px;
        height: 640px;
        border: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        background: #000;
        touch-action: auto;
      }
      @media (max-width: 1000px) {
        .pipepuzzle_iframe {
          width: 100%;
          height: 100%;
          border-radius: 0;
        }
      }
      #pipepuzzle_close_hint {
        position: absolute;
        top: 12px;
        right: 12px;
        z-index: 100000;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 14px;
        user-select: none;
        display: none;
      }
      #pipepuzzle_iframe_wrap.show #pipepuzzle_close_hint {
        display: block;
      }

      /* Android resume overlay: captures a real touch/hold */
      #touch_resume_overlay {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        z-index: 100001;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(
          0,
          0,
          0,
          0
        ); /* transparent overall to let user see game */
        -webkit-tap-highlight-color: transparent;
      }
      #touch_resume_box {
        pointer-events: none; /* message doesn't capture pointer; overlay does */
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        padding: 10px 14px;
        border-radius: 8px;
        font-size: 14px;
      }
      /* small visible hint on Android 15 only */
      #touch_resume_overlay.show #touch_resume_box {
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <script>
      if (location.protocol.substr(0, 4) === "file") {
        alert(
          "Web exports won't work until you upload them. (file: protocol blocks features.)"
        );
      }
    </script>

    <noscript>
      <div id="notSupportedWrap">
        <h2 id="notSupportedTitle">This content requires JavaScript</h2>
        <p class="notSupportedMessage">
          JavaScript appears to be disabled. Please enable it to view this
          content.
        </p>
      </div>
    </noscript>

    <script src="scripts/modernjscheck.js"></script>
    <script src="scripts/supportcheck.js"></script>
    <script src="scripts/offlineclient.js" type="module"></script>
    <script src="scripts/main.js" type="module"></script>
    <script src="scripts/register-sw.js" type="module"></script>

    <div
      id="pipepuzzle_iframe_wrap"
      aria-hidden="true"
      role="dialog"
      tabindex="-1"
    >
      <!-- <div id="pipepuzzle_close_hint">Tap outside to close</div> -->
      <!-- iframe will be injected dynamically -->
    </div>

    <!-- Android resume overlay -->
    <div
      id="touch_resume_overlay"
      aria-hidden="true"
      role="button"
      tabindex="0"
    >
      <div id="touch_resume_box">Tap &amp; hold anywhere to resume</div>
    </div>

    <script>
      (function () {
        const iframeWrap = document.getElementById("pipepuzzle_iframe_wrap");
        const touchResume = document.getElementById("touch_resume_overlay");
        const touchBox = document.getElementById("touch_resume_box");
        const PIPE_URL = "./PipePuzzlee/index.html";
        let iframe = null;

        const ua = navigator.userAgent || "";
        const isAndroid = /Android\/?(\d+)?/i.test(ua);
        // parse Android major version if present
        function androidMajorVersion() {
          const m = ua.match(/Android\s+(\d+)(?:[.\d]*)/i);
          if (!m) return null;
          const v = parseInt(m[1], 10);
          return isNaN(v) ? null : v;
        }
        const androidVer = androidMajorVersion();
        const isChrome = /Chrome\/\d+/i.test(ua) || /CriOS\/\d+/i.test(ua);
        const isAndroid15Chrome = androidVer === 15 && isChrome;

        function findGameCanvas() {
          return (
            document.getElementById("c2canvas") ||
            document.getElementById("c3canvas") ||
            document.querySelector("canvas")
          );
        }

        function clearSelectionAndBlur() {
          try {
            if (window.getSelection) {
              const s = window.getSelection();
              if (s && s.removeAllRanges) s.removeAllRanges();
            }
            if (
              document.activeElement &&
              typeof document.activeElement.blur === "function"
            ) {
              document.activeElement.blur();
            }
          } catch (e) {}
        }

        function safeDispatchEvent(target, ev) {
          if (!target) return;
          try {
            target.dispatchEvent(ev);
          } catch (e) {}
        }

        function dispatchRecoveryEventsTo(target) {
          if (!target) return;
          try {
            const pDown = new PointerEvent("pointerdown", {
              bubbles: true,
              cancelable: true,
            });
            const pUp = new PointerEvent("pointerup", {
              bubbles: true,
              cancelable: true,
            });
            const pCancel = new PointerEvent("pointercancel", {
              bubbles: true,
              cancelable: true,
            });
            safeDispatchEvent(target, pDown);
            safeDispatchEvent(target, pUp);
            safeDispatchEvent(target, pCancel);
          } catch (e) {
            try {
              safeDispatchEvent(
                target,
                new MouseEvent("mouseup", { bubbles: true, cancelable: true })
              );
            } catch (ee) {}
          }

          try {
            safeDispatchEvent(
              target,
              new MouseEvent("click", { bubbles: true, cancelable: true })
            );
          } catch (e) {}
          try {
            safeDispatchEvent(
              target,
              new KeyboardEvent("keyup", { bubbles: true, cancelable: true })
            );
          } catch (e) {}
        }

        // Very aggressive wake routine with repeats
        function wakeParentInput(attemptsRemaining) {
          try {
            document.body.style.pointerEvents = "auto";
            document.body.style.touchAction = "auto";

            clearSelectionAndBlur();
            try {
              window.focus && window.focus();
            } catch (e) {}

            const canvas = findGameCanvas();
            if (canvas) {
              try {
                canvas.style.touchAction = "auto";
              } catch (e) {}
              try {
                canvas.style.pointerEvents = "auto";
              } catch (e) {}
              try {
                canvas.focus && canvas.focus();
              } catch (e) {}
              dispatchRecoveryEventsTo(canvas);
            }

            try {
              const cx = Math.round(window.innerWidth / 2);
              const cy = Math.round(window.innerHeight / 2);
              const el = document.elementFromPoint(cx, cy);
              if (el) dispatchRecoveryEventsTo(el);
            } catch (e) {}

            dispatchRecoveryEventsTo(document.body);

            if (attemptsRemaining > 0) {
              const delay = isAndroid15Chrome ? 140 : 60;
              setTimeout(() => wakeParentInput(attemptsRemaining - 1), delay);
            }
          } catch (e) {
            console.warn("wakeParentInput failed", e);
          }
        }

        // show resume overlay for Android 15; overlay listens for *real* touch hold
        function showTouchResumeOverlay() {
          touchResume.style.display = "flex";
          touchResume.style.pointerEvents = "auto";
          touchResume.setAttribute("aria-hidden", "false");
          touchResume.classList.add("show");

          let holdTimer = null;
          let pointerDownTime = 0;
          const HOLD_THRESHOLD = 300; // ms — tuned for Android15 (adjust up to 400ms if needed)
          let handled = false;

          function cleanup() {
            handled = true;
            touchResume.style.display = "none";
            touchResume.style.pointerEvents = "none";
            touchResume.setAttribute("aria-hidden", "true");
            touchResume.classList.remove("show");
            touchResume.removeEventListener("touchstart", onTouchStart, {
              passive: false,
            });
            touchResume.removeEventListener("pointerdown", onPointerDown);
            touchResume.removeEventListener("touchend", onTouchEnd);
            touchResume.removeEventListener("pointerup", onPointerUp);
            touchResume.removeEventListener("click", onClick, true);
            document.removeEventListener(
              "visibilitychange",
              onVisibilityChange
            );
            if (holdTimer) {
              clearTimeout(holdTimer);
              holdTimer = null;
            }
          }

          function doRecoveryByUserTouch() {
            if (handled) return;
            cleanup();
            // run aggressive wake (user performed a real touch)
            setTimeout(() => wakeParentInput(4), 8);
          }

          function onTouchStart(e) {
            // stop propagation and prevent passive default to capture touch
            try {
              e.preventDefault && e.preventDefault();
            } catch (err) {}
            pointerDownTime = Date.now();
            // start hold timer
            holdTimer = setTimeout(
              () => doRecoveryByUserTouch(),
              HOLD_THRESHOLD
            );
          }
          function onPointerDown(e) {
            try {
              e.preventDefault && e.preventDefault();
            } catch (err) {}
            pointerDownTime = Date.now();
            holdTimer = setTimeout(
              () => doRecoveryByUserTouch(),
              HOLD_THRESHOLD
            );
          }
          function onTouchEnd(e) {
            try {
              e.preventDefault && e.preventDefault();
            } catch (err) {}
            const dt = Date.now() - pointerDownTime;
            if (holdTimer) {
              clearTimeout(holdTimer);
              holdTimer = null;
            }
            // treat short taps as fallback but prefer hold — short tap triggers recovery attempt too
            if (dt < HOLD_THRESHOLD) {
              // run recovery but still prefer hold: run with more retries
              cleanup();
              setTimeout(() => wakeParentInput(3), 20);
            }
          }
          function onPointerUp(e) {
            try {
              e.preventDefault && e.preventDefault();
            } catch (err) {}
            const dt = Date.now() - pointerDownTime;
            if (holdTimer) {
              clearTimeout(holdTimer);
              holdTimer = null;
            }
            if (dt < HOLD_THRESHOLD) {
              cleanup();
              setTimeout(() => wakeParentInput(3), 20);
            }
          }
          function onClick(e) {
            // prevent synthetic click propagation
            try {
              e.stopPropagation && e.stopPropagation();
              e.preventDefault && e.preventDefault();
            } catch (e) {}
          }
          function onVisibilityChange() {
            // if app lost visibility (user switched), hide overlay
            if (document.hidden) {
              cleanup();
            }
          }

          // Attach listeners. Use non-passive touchstart so preventDefault works.
          touchResume.addEventListener("touchstart", onTouchStart, {
            passive: false,
          });
          touchResume.addEventListener("pointerdown", onPointerDown);
          touchResume.addEventListener("touchend", onTouchEnd);
          touchResume.addEventListener("pointerup", onPointerUp);
          // capture clicks to block propagation to the game while overlay active
          touchResume.addEventListener("click", onClick, true);
          document.addEventListener("visibilitychange", onVisibilityChange);
        }

        function hideTouchResumeOverlay() {
          touchResume.style.display = "none";
          touchResume.style.pointerEvents = "none";
          touchResume.setAttribute("aria-hidden", "true");
          touchResume.classList.remove("show");
        }

        // open iframe
        window.openPipePuzzle = function (url) {
          try {
            if (iframe) return;
            iframe = document.createElement("iframe");
            iframe.className = "pipepuzzle_iframe";
            iframe.id = "pipepuzzle_iframe";
            iframe.src = url || PIPE_URL;
            iframe.title = "PipePuzzle";
            iframe.setAttribute(
              "allow",
              "fullscreen; autoplay; clipboard-read; clipboard-write"
            );
            iframe.setAttribute(
              "sandbox",
              "allow-scripts allow-same-origin allow-forms allow-popups"
            );
            iframeWrap.appendChild(iframe);

            iframeWrap.style.display = "flex";
            iframeWrap.classList.add("show");
            iframeWrap.style.pointerEvents = "auto";
            iframeWrap.setAttribute("aria-hidden", "false");

            iframe.addEventListener(
              "load",
              () => {
                try {
                  iframe.contentWindow &&
                    iframe.contentWindow.focus &&
                    iframe.contentWindow.focus();
                } catch (e) {}
              },
              { once: true }
            );
          } catch (e) {
            console.error("openPipePuzzle failed", e);
          }
        };

        // close iframe: remove from DOM, run recovery; on Android 15 show tap&hold overlay
        window.closePipePuzzle = function () {
          try {
            if (iframe) {
              try {
                iframe.src = "about:blank";
              } catch (e) {}
              try {
                iframe.remove();
              } catch (e) {
                iframe.parentNode && iframe.parentNode.removeChild(iframe);
              }
              iframe = null;
            }

            iframeWrap.style.display = "none";
            iframeWrap.classList.remove("show");
            iframeWrap.style.pointerEvents = "none";
            iframeWrap.setAttribute("aria-hidden", "true");

            // automated synthetic recovery attempts first
            setTimeout(() => wakeParentInput(isAndroid15Chrome ? 2 : 1), 40);

            // For Android 15 Chrome show the Tap & Hold overlay to guarantee a REAL touch event.
            if (isAndroid15Chrome) {
              // show after a short delay so user sees the transition
              setTimeout(() => showTouchResumeOverlay(), 80);
              // fallback auto-hide after 8s (overlay optional)
              setTimeout(() => {
                try {
                  hideTouchResumeOverlay();
                } catch (e) {}
              }, 8000);
            }
          } catch (e) {
            console.warn("closePipePuzzle error", e);
          }
        };

        // Close when clicking outside iframe
        iframeWrap.addEventListener("click", function (ev) {
          if (ev.target === iframeWrap)
            window.closePipePuzzle && window.closePipePuzzle();
        });

        // Escape key support
        window.addEventListener("keydown", function (ev) {
          if (ev.key === "Escape" && iframe)
            window.closePipePuzzle && window.closePipePuzzle();
        });

        // PostMessage from iframe (keep previous behavior)
        window.addEventListener(
          "message",
          function (event) {
            try {
              const data = event.data;
              if (!data || !data.type) return;
              if (data.type === "levelComplete") {
                window.closePipePuzzle();
                console.log(
                  "Parent received levelComplete from PipePuzzle",
                  data
                );
                try {
                  if (
                    window.runtime &&
                    typeof window.runtime.callFunction === "function"
                  ) {
                    window.runtime.callFunction(
                      "FromIframe",
                      JSON.stringify(data)
                    );
                  } else if (typeof window.CallFunction === "function") {
                    window.CallFunction("FromIframe", JSON.stringify(data));
                  } else {
                    console.warn(
                      'Construct runtime.callFunction not found. Add a Function event "FromIframe" or adjust integration.'
                    );
                  }
                } catch (e) {
                  console.warn("Error calling Construct function:", e);
                }
              }
            } catch (e) {
              console.warn(e);
            }
          },
          false
        );

        console.log(
          "PipePuzzle integration ready. Android ver:",
          androidVer,
          "isChrome:",
          isChrome,
          "Android15Fix:",
          isAndroid15Chrome
        );
      })();
    </script>
  </body>
</html>
