<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Dhurandar</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"
    />
    <meta name="generator" content="Scirra Construct" />
    <meta name="author" content="JioGames" />
    <link rel="manifest" href="appmanifest.json" />
    <link rel="apple-touch-icon" sizes="128x128" href="icons/icon-128.png" />
    <link rel="apple-touch-icon" sizes="256x256" href="icons/icon-256.png" />
    <link rel="apple-touch-icon" sizes="512x512" href="icons/icon-512.png" />
    <link rel="icon" type="image/png" href="icons/icon-512.png" />
    <link rel="stylesheet" href="style.css" />
    <style>
      /* minimal safety defaults so mobile browsers behave more predictably */
      html, body {
        -webkit-user-select: none;
        -ms-user-select: none;
        user-select: none;
        touch-action: manipulation;
      }
    </style>
  </head>

  <body>
    <script>
      if (location.protocol.substr(0, 4) === "file") {
        alert(
          "Web exports won't work until you upload them. (When running on the file: protocol, browsers block many features from working for security reasons.)"
        );
      }
    </script>

    <noscript>
      <div id="notSupportedWrap">
        <h2 id="notSupportedTitle">This content requires JavaScript</h2>
        <p class="notSupportedMessage">
          JavaScript appears to be disabled. Please enable it to view this
          content.
        </p>
      </div>
    </noscript>

    <script src="scripts/modernjscheck.js"></script>
    <script src="scripts/supportcheck.js"></script>
    <script src="scripts/offlineclient.js" type="module"></script>
    <script src="scripts/main.js" type="module"></script>
    <script src="scripts/register-sw.js" type="module"></script>

    <!-- PipePuzzle iframe overlay (integrator) -->
    <style>
      #pipepuzzle_iframe_wrap {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 99999;
        pointer-events: none; /* non-interactive when hidden */
        -webkit-tap-highlight-color: transparent;
      }
      .pipepuzzle_iframe {
        width: 960px;
        height: 640px;
        border: none;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        background: #000;
        touch-action: auto;
      }
      @media (max-width: 1000px) {
        .pipepuzzle_iframe {
          width: 100%;
          height: 100%;
          border-radius: 0;
        }
      }
      #pipepuzzle_close_hint {
        position: absolute;
        top: 12px;
        right: 12px;
        z-index: 100000;
        background: rgba(0,0,0,0.5);
        color: #fff;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 14px;
        user-select: none;
        -webkit-user-select: none;
        display: none;
      }
      #pipepuzzle_iframe_wrap.show #pipepuzzle_close_hint { display: block; }
    </style>

    <div id="pipepuzzle_iframe_wrap" aria-hidden="true" role="dialog" tabindex="-1">
      <!-- <div id="pipepuzzle_close_hint">Tap outside to close</div> -->
      <!-- iframe inserted dynamically -->
    </div>

    <script>
      (function () {
        const iframeWrap = document.getElementById("pipepuzzle_iframe_wrap");
        const closeHint = document.getElementById("pipepuzzle_close_hint");
        const PIPE_URL = "./PipePuzzlee/index.html";
        let iframe = null;

        // Detect Android Chrome user agent (best-effort)
        const ua = navigator.userAgent || navigator.vendor || "";
        const isAndroid = /Android/i.test(ua);
        const isChrome = /Chrome\/\d+/i.test(ua) || /CriOS\/\d+/i.test(ua); // include iOS Chrome if any
        const useAndroidAggressive = isAndroid && isChrome;

        function findGameCanvas() {
          return (
            document.getElementById("c2canvas") ||
            document.getElementById("c3canvas") ||
            document.querySelector("canvas")
          );
        }

        function clearSelectionAndBlur() {
          try {
            if (window.getSelection) {
              const sel = window.getSelection();
              if (sel && sel.removeAllRanges) sel.removeAllRanges();
            }
            if (document.activeElement && typeof document.activeElement.blur === "function") {
              document.activeElement.blur();
            }
          } catch (e) {}
        }

        function safeDispatchEvent(target, ev) {
          if (!target) return;
          try {
            target.dispatchEvent(ev);
          } catch (e) {}
        }

        // Compose and dispatch a set of synthetic events to help Android Chrome release capture
        function dispatchRecoveryEventsTo(target) {
          if (!target) return;
          // pointer events
          try {
            const pDown = new PointerEvent("pointerdown", { bubbles: true, cancelable: true });
            const pUp = new PointerEvent("pointerup", { bubbles: true, cancelable: true });
            const pCancel = new PointerEvent("pointercancel", { bubbles: true, cancelable: true });
            safeDispatchEvent(target, pDown);
            safeDispatchEvent(target, pUp);
            safeDispatchEvent(target, pCancel);
          } catch (e) {
            // fallback mouse events
            try {
              const mu = new MouseEvent("mouseup", { bubbles: true, cancelable: true });
              safeDispatchEvent(target, mu);
            } catch (ee) {}
          }

          // send a click event
          try {
            const clickEv = new MouseEvent("click", { bubbles: true, cancelable: true });
            safeDispatchEvent(target, clickEv);
          } catch (e) {}

          // send a lightweight keyup for good measure
          try {
            const ku = new KeyboardEvent("keyup", { bubbles: true, cancelable: true });
            safeDispatchEvent(target, ku);
          } catch (e) {}
        }

        // Wake routine: repeated attempts to restore input handlers
        function wakeParentInput(attemptsRemaining) {
          try {
            // restore page pointer behavior
            document.body.style.pointerEvents = "auto";
            document.body.style.touchAction = "auto";

            clearSelectionAndBlur();

            try { window.focus && window.focus(); } catch (e) {}

            const canvas = findGameCanvas();
            if (canvas) {
              try { canvas.style.touchAction = "auto"; } catch (e) {}
              try { canvas.style.pointerEvents = "auto"; } catch (e) {}
              try { canvas.focus && canvas.focus(); } catch (e) {}
              dispatchRecoveryEventsTo(canvas);
            }

            // dispatch to center element (helps Android Chrome)
            try {
              const cx = Math.round(window.innerWidth / 2);
              const cy = Math.round(window.innerHeight / 2);
              const centerEl = document.elementFromPoint(cx, cy);
              if (centerEl) {
                dispatchRecoveryEventsTo(centerEl);
              }
            } catch (e) {}

            // Also dispatch to body as a last fallback
            dispatchRecoveryEventsTo(document.body);

            // If Android Chrome, repeat more times and slightly longer delay
            if (attemptsRemaining > 0) {
              const delay = useAndroidAggressive ? 120 : 60;
              setTimeout(() => wakeParentInput(attemptsRemaining - 1), delay);
            }
          } catch (e) {
            console.warn("wakeParentInput failed", e);
          }
        }

        // Public open
        window.openPipePuzzle = function (url) {
          try {
            if (iframe) return;
            iframe = document.createElement("iframe");
            iframe.className = "pipepuzzle_iframe";
            iframe.id = "pipepuzzle_iframe";
            iframe.src = url || PIPE_URL;
            iframe.title = "PipePuzzle";
            iframe.setAttribute("allow", "fullscreen; autoplay; clipboard-read; clipboard-write");
            iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms allow-popups"); // adjust as needed
            iframeWrap.appendChild(iframe);

            // show overlay and make it interactive
            iframeWrap.style.display = "flex";
            iframeWrap.classList.add("show");
            iframeWrap.style.pointerEvents = "auto";
            iframeWrap.setAttribute("aria-hidden", "false");

            // focus iframe after load
            iframe.addEventListener("load", () => {
              try { iframe.contentWindow && iframe.contentWindow.focus && iframe.contentWindow.focus(); } catch (e) {}
            }, { once: true });
          } catch (e) {
            console.error("openPipePuzzle failed", e);
          }
        };

        // Public close
        window.closePipePuzzle = function () {
          try {
            if (iframe) {
              try { iframe.src = "about:blank"; } catch (e) {}
              try { iframe.remove(); } catch (e) { iframe.parentNode && iframe.parentNode.removeChild(iframe); }
              iframe = null;
            }

            // hide overlay and make it non-interactive
            iframeWrap.style.display = "none";
            iframeWrap.classList.remove("show");
            iframeWrap.style.pointerEvents = "none";
            iframeWrap.setAttribute("aria-hidden", "true");

            // run aggressive wake sequence
            const attempts = useAndroidAggressive ? 4 : 2; // more tries for Android Chrome
            // small initial delay to allow reflow, then run wake attempts
            setTimeout(() => wakeParentInput(attempts), 40);
          } catch (e) {
            console.warn("closePipePuzzle error", e);
          }
        };

        // Close when clicking outside iframe (wrapper) â€” only if user taps background
        iframeWrap.addEventListener("click", function (ev) {
          if (ev.target === iframeWrap) {
            window.closePipePuzzle && window.closePipePuzzle();
          }
        });

        // Escape key support
        window.addEventListener("keydown", function (ev) {
          if (ev.key === "Escape" && iframe) {
            window.closePipePuzzle && window.closePipePuzzle();
          }
        });

        // PostMessage handler
        window.addEventListener("message", function (event) {
          try {
            const data = event.data;
            if (!data || !data.type) return;
            if (data.type === "levelComplete") {
              window.closePipePuzzle();
              console.log("Parent received levelComplete from PipePuzzle", data);
              try {
                if (window.runtime && typeof window.runtime.callFunction === "function") {
                  window.runtime.callFunction("FromIframe", JSON.stringify(data));
                } else if (typeof window.CallFunction === "function") {
                  window.CallFunction("FromIframe", JSON.stringify(data));
                } else {
                  console.warn('Construct runtime.callFunction not found. Add a Function event "FromIframe" or adjust integration.');
                }
              } catch (e) {
                console.warn("Error calling Construct function:", e);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }, false);

        console.log("PipePuzzle integration ready. Call window.openPipePuzzle() to open the embedded level.");
      })();
    </script>
  </body>
</html>
